#include "/Engine/Private/Common.ush"
#include "/Engine/Private/SceneTexturesCommon.ush"
#include "/Engine/Private/SceneTextureParameters.ush"

float2 ViewportSize;

float2 TextureSize;
float2 TextureSizeInverse;

Texture2D<float4> SourceTexture;
Texture2D<float4> SecondaryTexture;

float FloodStepSize;

float2 CopyDestinationResolution;

float2 PointSampleUV(float2 UV)
{
	return (floor(UV * TextureSize) + 0.5) * TextureSizeInverse;
}

float PackTwoNormalizedFloats(float A, float B)
{
	int Precision = 4096;
	int PrecisionMinusOne = Precision - 1;

	A = floor(A * PrecisionMinusOne);
	B = floor(B * PrecisionMinusOne);

	return (A * Precision) + B;
}

float2 UnpackTwoNormalizedFloats(float Packed)
{
	const int Precision = 4096;
	const float PrecisionInverse = 0.000244140625;
	const float PrecisionMinusOneInverse = 0.0002442002442002442;

	float2 Output = 0;
	Output.x = floor(Packed * PrecisionInverse);
	Output.y = Packed - Output.x * Precision;
	Output *= PrecisionMinusOneInverse;

	return Output;
}

float SobelEdgeDetection(float2 ScreenPosition)
{
	float KernelX[3][3] =
	{
		{ -1,  0,  1 },
		{ -2,  0,  2 },
		{ -1,  0,  1 }
	};

	float KernelY[3][3] =
	{
		{ -1, -2, -1 },
		{  0,  0,  0 },
		{  1,  2,  1 }
	};

	float Gx = 0.0;
	float Gy = 0.0;

	// Sample 3x3 neighborhood
	for (int i = -1; i <= 1; i++)
	{
		for (int j = -1; j <= 1; j++)
		{
			float2 OffsetScreenPosition = ScreenPosition + float2(i, j);
			float Stencil = CalcSceneCustomStencil(OffsetScreenPosition);

			Gx += Stencil * KernelX[i + 1][j + 1];
			Gy += Stencil * KernelY[i + 1][j + 1];
		}
	}

	return (Gx * Gx + Gy * Gy);
}

float SquareDistance(float2 A, float2 B)
{
	return Square(B.x-A.x) + Square(B.y-A.y);
}

void SeedPS(float4 SvPosition : SV_POSITION, out float4 PrimaryOutput : SV_Target0, out float4 SecondaryOutput : SV_Target1) {
	float4 Color = float4(0.0, 0.0, 0.0, 0.0);

	const float2 PixelPosition = SvPosition.xy;
	const float2 UV = PixelPosition * TextureSizeInverse;
	const float2 ScreenPosition = UV * ViewportSize;

	PrimaryOutput   = float4(0.0, 0.0, 0.0, 0.0);
	SecondaryOutput = float4(0.0, 0.0, 0.0, 0.0);

	int StencilValue = CalcSceneCustomStencil(ScreenPosition);
	if (StencilValue > 0)
	{
		Color.a = -1.0;
		if (SobelEdgeDetection(ScreenPosition) > 0)
		{
			PrimaryOutput = float4(PixelPosition, 0.0, 1.0);
			SecondaryOutput = float4(StencilValue, 0.0, 0.0, 0.0);
		}
	}
}

void FloodPS(float4 SvPosition : SV_POSITION, out float4 PrimaryOutput : SV_Target0, out float4 SecondaryOutput : SV_Target1)
{
	const float2 PixelPosition = SvPosition.xy;

	PrimaryOutput = SourceTexture.Load(int3(PixelPosition, 0));
	SecondaryOutput = SecondaryTexture.Load(int3(PixelPosition, 0));

	float MaxDist = 1e20;

	if (PrimaryOutput.a != 0)
	{
		MaxDist = SquareDistance(PixelPosition, PrimaryOutput.rg);
	}

	for (int X = -1; X <= 1; X += 1)
	{
		for (int Y = -1; Y <= 1; Y += 1)
		{
			if (X == 0 && Y == 0) continue;

			float2 Offset = float2(X, Y) * FloodStepSize;

			float4 PrimarySample = SourceTexture.Load(int3(PixelPosition + Offset, 0));
			if (PrimarySample.a != 0)
			{
				float DistanceSquared = SquareDistance(PixelPosition, PrimarySample.rg);
				if (DistanceSquared < MaxDist)
				{
					PrimaryOutput = PrimarySample;
					PrimaryOutput.b = DistanceSquared;

					SecondaryOutput = SecondaryTexture.Load(int3(PixelPosition + Offset, 0));

					MaxDist = DistanceSquared;
				}
			}
		}
	}
}

void CopyPS(in float4 SVPos : SV_POSITION, out float4 PrimaryOutput : SV_Target0, out float4 SecondaryOutput : SV_Target1)
{
	float4 PrimarySample = SourceTexture.Load(int3(SVPos.xy, 0));
	float4 SecondarySample = SecondaryTexture.Load(int3(SVPos.xy, 0));

	//  Wanted to wrap these in a branch, but doing that causes unreal to remove passes??
	PrimaryOutput.rg = PrimarySample.rg / CopyDestinationResolution;
	PrimaryOutput.b = sqrt(PrimarySample.b) * PrimarySample.a;	// This converts the distance field to a signed distance field, applying the alpha's setup in a Seed Pass
	PrimaryOutput.a = abs(PrimarySample.a);

	//  Valid Stencils will never be 0
	if (PrimaryOutput.g == 0)
	{
		PrimaryOutput.a = 0;
	}

	SecondaryOutput = SecondarySample;
	SecondaryOutput.r /= 255.0;
}
